{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.getIncrementer = getIncrementer;\nexports.transformData = transformData;\nexports.getVisibleDataForColumns = getVisibleDataForColumns;\nexports.hasColumnProperties = hasColumnProperties;\nexports.hasData = hasData;\nexports.addColumnPropertiesWhenNoneExist = addColumnPropertiesWhenNoneExist;\n\nvar _immutable = require('immutable');\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} //From Immutable docs - https://github.com/facebook/immutable-js/wiki/Predicates\n\n\nfunction keyInArray(keys) {\n  var keySet = _immutable2.default.Set(keys);\n\n  return function (v, k) {\n    return keySet.has(k);\n  };\n}\n\nfunction getIncrementer(startIndex) {\n  var key = startIndex;\n  return function () {\n    return key++;\n  };\n}\n\nfunction isImmutableConvertibleValue(value) {\n  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== 'object' || value === null || value instanceof Date;\n} // From https://github.com/facebook/immutable-js/wiki/Converting-from-JS-objects#custom-conversion\n\n\nfunction fromJSGreedy(js) {\n  return isImmutableConvertibleValue(js) ? js : Array.isArray(js) ? _immutable2.default.Seq(js).map(fromJSGreedy).toList() : _immutable2.default.Seq(js).map(fromJSGreedy).toMap();\n}\n\nfunction transformData(data, renderProperties) {\n  if (!data) {\n    return {};\n  }\n\n  var hasCustomRowId = renderProperties.rowProperties && renderProperties.rowProperties.rowKey; // Validate that the first item in our data has the custom Griddle key\n\n  if (hasCustomRowId && data.length > 0 && !data[0].hasOwnProperty(renderProperties.rowProperties.rowKey)) {\n    throw new Error('Griddle: Property \\'' + renderProperties.rowProperties.rowKey + '\\' doesn\\'t exist in row data. Please specify a rowKey that exists in <RowDefinition>');\n  }\n\n  var list = [];\n  var lookup = {};\n  data.forEach(function (rowData, index) {\n    var map = fromJSGreedy(rowData); // if this has a row key use that -- otherwise use Griddle key\n\n    var key = hasCustomRowId ? rowData[renderProperties.rowProperties.rowKey] : index; // if our map object already has griddleKey use that -- otherwise add key as griddleKey\n\n    var keyedData = map.has('griddleKey') ? map : map.set('griddleKey', key);\n    list.push(keyedData);\n    lookup[key] = index;\n  });\n  return {\n    data: new _immutable2.default.List(list),\n    lookup: new _immutable2.default.Map(lookup)\n  };\n}\n/** Gets the visible data based on columns\n *  @param (List<Map>) data - data collection\n *  @param (array<string>) columns - list of columns to display\n *\n *  TODO: Needs tests\n */\n\n\nfunction getVisibleDataForColumns(data, columns) {\n  if (data.size < 1) {\n    return data;\n  }\n\n  var dataColumns = data.get(0).keySeq().toArray();\n  var metadataColumns = dataColumns.filter(function (item) {\n    return columns.indexOf(item) < 0;\n  }); //if columns are specified but aren't in the data\n  //make it up (as null). We will append this column\n  //to the resultant data\n\n  var magicColumns = columns.filter(function (item) {\n    return dataColumns.indexOf(item) < 0;\n  }).reduce(function (original, item) {\n    original[item] = null;\n    return original;\n  }, {}); //combine the metadata and the \"magic\" columns\n\n  var extra = data.map(function (d, i) {\n    return new _immutable2.default.Map(Object.assign(magicColumns));\n  });\n  var result = data.map(function (d) {\n    return d.filter(keyInArray(columns));\n  });\n  return result.mergeDeep(extra).map(function (item) {\n    return item.sortBy(function (val, key) {\n      return columns.indexOf(key) > -1 ? columns.indexOf(key) : MAX_SAFE_INTEGER;\n    });\n  });\n}\n/* TODO: Add documentation and tests for this whole section!*/\n\n/** Does this initial state object have column properties?\n * @param (object) stateObject - a non-immutable state object for initialization\n *\n * TODO: Needs tests\n */\n\n\nfunction hasColumnProperties(stateObject) {\n  return stateObject.hasOwnProperty('renderProperties') && stateObject.renderProperties.hasOwnProperty('columnProperties') && Object.keys(stateObject.renderProperties.columnProperties).length > 0;\n}\n/** Does this initial state object have data?\n * @param (object) stateObject - a non-immutable state object for initialization\n */\n\n\nfunction hasData(stateObject) {\n  return !!stateObject.data && stateObject.data.length > 0;\n}\n/** Gets a new state object (not immutable) that has columnProperties if none exist\n * @param (object) stateObject - a non-immutable state object for initialization\n *\n * TODO: Needs tests\n */\n\n\nfunction addColumnPropertiesWhenNoneExist(stateObject) {\n  if (!hasData(stateObject) || hasColumnProperties(stateObject)) {\n    return stateObject;\n  }\n\n  return _extends({}, stateObject, {\n    renderProperties: {\n      columnProperties: Object.keys(stateObject.data[0]).reduce(function (previous, current) {\n        previous[current] = {\n          id: current,\n          visible: true\n        };\n        return previous;\n      }, {})\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}
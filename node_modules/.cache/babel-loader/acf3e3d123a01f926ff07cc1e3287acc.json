{"ast":null,"code":"import _objectSpread from \"/Users/Greg/Desktop/react/summer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _objectWithoutProperties from \"/Users/Greg/Desktop/react/summer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"/Users/Greg/Desktop/react/summer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/Greg/Desktop/react/summer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/Greg/Desktop/react/summer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/Greg/Desktop/react/summer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/Greg/Desktop/react/summer/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/Greg/Desktop/react/summer/src/components/dndDemo.jsx\";\nimport React, { Component } from 'react';\nimport { Table, Card } from 'antd';\nimport { DragDropContext, DragSource, DropTarget, ConnectDropTarget, ConnectDragSource, DropTargetMonitor, DropTargetConnector, DragSourceConnector, DragSourceMonitor } from 'react-dnd';\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport update from 'immutability-helper';\nimport './dashboard.css';\nimport { XYCoord } from 'dnd-core';\nvar Types = {\n  CARD1: 'card1'\n};\nvar cardSource = {\n  beginDrag: function beginDrag(props) {\n    // Return the data describing the dragged item\n    var item = {\n      id: props.id\n    };\n    return item;\n  },\n  endDrag: function endDrag(props, monitor, component, CardActions) {\n    if (!monitor.didDrop()) {\n      return;\n    } // When dropped on a compatible target, do something\n\n\n    var item = monitor.getItem();\n    var dropResult = monitor.getDropResult();\n    CardActions.moveCardToList(item.id, dropResult.listId);\n  }\n};\n/**\n * Specifies which props to inject into your component.\n */\n\nfunction collect(connect, monitor) {\n  return {\n    // Call this function inside render()\n    // to let React DnD handle the drag events:\n    connectDragSource: connect.dragSource(),\n    // You can ask the monitor about the current drag state:\n    isDragging: monitor.isDragging()\n  };\n}\n\nfunction Card1(props) {\n  // Your component receives its own props as usual\n  var id = props.id; // These two props are injected by React DnD,\n  // as defined by your `collect` function above:\n\n  var isDragging = props.isDragging,\n      connectDragSource = props.connectDragSource;\n  return connectDragSource(React.createElement(\"div\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57\n    },\n    __self: this\n  }, \"I am a draggable card number \", id, isDragging && ' (and I am being dragged now)'));\n}\n\nvar dragingIndex = -1;\n\nvar BodyRow =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(BodyRow, _React$Component);\n\n  function BodyRow() {\n    _classCallCheck(this, BodyRow);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(BodyRow).apply(this, arguments));\n  }\n\n  _createClass(BodyRow, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          isOver = _this$props.isOver,\n          connectDragSource = _this$props.connectDragSource,\n          connectDropTarget = _this$props.connectDropTarget,\n          moveRow = _this$props.moveRow,\n          restProps = _objectWithoutProperties(_this$props, [\"isOver\", \"connectDragSource\", \"connectDropTarget\", \"moveRow\"]);\n\n      var style = _objectSpread({}, restProps.style, {\n        cursor: 'move'\n      });\n\n      var className = restProps.className;\n\n      if (isOver) {\n        if (restProps.index > dragingIndex) {\n          className += ' drop-over-downward';\n        }\n\n        if (restProps.index < dragingIndex) {\n          className += ' drop-over-upward';\n        }\n      }\n\n      return connectDragSource(connectDropTarget(React.createElement(\"tr\", Object.assign({}, restProps, {\n        className: className,\n        style: style,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 92\n        },\n        __self: this\n      }))));\n    }\n  }]);\n\n  return BodyRow;\n}(React.Component);\n\nvar rowSource = {\n  beginDrag: function beginDrag(props) {\n    dragingIndex = props.index;\n    return {\n      index: props.index\n    };\n  }\n};\nvar rowTarget = {\n  drop: function drop(props, monitor) {\n    var dragIndex = monitor.getItem().index;\n    var hoverIndex = props.index; // Don't replace items with themselves\n\n    if (dragIndex === hoverIndex) {\n      return;\n    } // Time to actually perform the action\n\n\n    props.moveRow(dragIndex, hoverIndex); // Note: we're mutating the monitor item here!\n    // Generally it's better to avoid mutations,\n    // but it's good here for the sake of performance\n    // to avoid expensive index searches.\n\n    monitor.getItem().index = hoverIndex;\n  }\n};\nvar DragableBodyRow = DropTarget('row', rowTarget, function (connect, monitor) {\n  return {\n    connectDropTarget: connect.dropTarget(),\n    isOver: monitor.isOver()\n  };\n})(DragSource('row', rowSource, function (connect) {\n  return {\n    connectDragSource: connect.dragSource()\n  };\n})(BodyRow));\nvar columns = [{\n  title: 'Name',\n  dataIndex: 'name',\n  key: 'name'\n}, {\n  title: 'Age',\n  dataIndex: 'age',\n  key: 'age'\n}, {\n  title: 'Address',\n  dataIndex: 'address',\n  key: 'address'\n}];\n\nvar DragSortingTable =\n/*#__PURE__*/\nfunction (_React$Component2) {\n  _inherits(DragSortingTable, _React$Component2);\n\n  function DragSortingTable() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, DragSortingTable);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(DragSortingTable)).call.apply(_getPrototypeOf2, [this].concat(args)));\n    _this.state = {\n      data: [{\n        key: '1',\n        name: 'John Brown',\n        age: 32,\n        address: 'New York No. 1 Lake Park'\n      }, {\n        key: '2',\n        name: 'Jim Green',\n        age: 42,\n        address: 'London No. 1 Lake Park'\n      }, {\n        key: '3',\n        name: 'Joe Black',\n        age: 32,\n        address: 'Sidney No. 1 Lake Park'\n      }]\n    };\n    _this.components = {\n      body: {\n        row: DragableBodyRow\n      }\n    };\n\n    _this.moveRow = function (dragIndex, hoverIndex) {\n      var data = _this.state.data;\n      var dragRow = data[dragIndex];\n\n      _this.setState(update(_this.state, {\n        data: {\n          $splice: [[dragIndex, 1], [hoverIndex, 0, dragRow]]\n        }\n      }));\n    };\n\n    return _this;\n  }\n\n  _createClass(DragSortingTable, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      return React.createElement(Table, {\n        columns: columns,\n        dataSource: this.state.data,\n        components: this.components,\n        onRow: function onRow(record, index) {\n          return {\n            index: index,\n            moveRow: _this2.moveRow\n          };\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 205\n        },\n        __self: this\n      });\n    }\n  }]);\n\n  return DragSortingTable;\n}(React.Component);\n\nvar Demo = DragDropContext(HTML5Backend)(DragSortingTable);\nexport default Demo;","map":{"version":3,"sources":["/Users/Greg/Desktop/react/summer/src/components/dndDemo.jsx"],"names":["React","Component","Table","Card","DragDropContext","DragSource","DropTarget","ConnectDropTarget","ConnectDragSource","DropTargetMonitor","DropTargetConnector","DragSourceConnector","DragSourceMonitor","HTML5Backend","update","XYCoord","Types","CARD1","cardSource","beginDrag","props","item","id","endDrag","monitor","component","CardActions","didDrop","getItem","dropResult","getDropResult","moveCardToList","listId","collect","connect","connectDragSource","dragSource","isDragging","Card1","dragingIndex","BodyRow","isOver","connectDropTarget","moveRow","restProps","style","cursor","className","index","rowSource","rowTarget","drop","dragIndex","hoverIndex","DragableBodyRow","dropTarget","columns","title","dataIndex","key","DragSortingTable","state","data","name","age","address","components","body","row","dragRow","setState","$splice","record","Demo"],"mappings":";;;;;;;;AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,SAASC,KAAT,EAAgBC,IAAhB,QAA4B,MAA5B;AACA,SAASC,eAAT,EAAyBC,UAAzB,EAAoCC,UAApC,EAA+CC,iBAA/C,EAAiEC,iBAAjE,EAAmFC,iBAAnF,EAAqGC,mBAArG,EAAyHC,mBAAzH,EAA6IC,iBAA7I,QACO,WADP;AAEA,OAAOC,YAAP,MAAyB,yBAAzB;AACA,OAAOC,MAAP,MAAmB,qBAAnB;AAEA,OAAO,iBAAP;AAEA,SAASC,OAAT,QAAwB,UAAxB;AAEA,IAAMC,KAAK,GAAG;AACZC,EAAAA,KAAK,EAAE;AADK,CAAd;AAIA,IAAMC,UAAU,GAAG;AACjBC,EAAAA,SADiB,qBACPC,KADO,EACA;AACf;AACA,QAAMC,IAAI,GAAG;AAAEC,MAAAA,EAAE,EAAEF,KAAK,CAACE;AAAZ,KAAb;AACA,WAAOD,IAAP;AACD,GALgB;AAOjBE,EAAAA,OAPiB,mBAOTH,KAPS,EAOFI,OAPE,EAOOC,SAPP,EAOkBC,WAPlB,EAO+B;AAC9C,QAAI,CAACF,OAAO,CAACG,OAAR,EAAL,EAAwB;AACtB;AACD,KAH6C,CAK9C;;;AACA,QAAMN,IAAI,GAAGG,OAAO,CAACI,OAAR,EAAb;AACA,QAAMC,UAAU,GAAGL,OAAO,CAACM,aAAR,EAAnB;AACAJ,IAAAA,WAAW,CAACK,cAAZ,CAA2BV,IAAI,CAACC,EAAhC,EAAoCO,UAAU,CAACG,MAA/C;AACD;AAhBgB,CAAnB;AAmBA;;;;AAGA,SAASC,OAAT,CAAiBC,OAAjB,EAA0BV,OAA1B,EAAmC;AACjC,SAAO;AACL;AACA;AACAW,IAAAA,iBAAiB,EAAED,OAAO,CAACE,UAAR,EAHd;AAIL;AACAC,IAAAA,UAAU,EAAEb,OAAO,CAACa,UAAR;AALP,GAAP;AAOD;;AAED,SAASC,KAAT,CAAelB,KAAf,EAAsB;AACpB;AADoB,MAEZE,EAFY,GAELF,KAFK,CAEZE,EAFY,EAIpB;AACA;;AALoB,MAMZe,UANY,GAMsBjB,KANtB,CAMZiB,UANY;AAAA,MAMAF,iBANA,GAMsBf,KANtB,CAMAe,iBANA;AAQpB,SAAOA,iBAAiB,CACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sCACgCb,EADhC,EAEGe,UAAU,IAAI,+BAFjB,CADsB,CAAxB;AAMD;;AAKD,IAAIE,YAAY,GAAG,CAAC,CAApB;;IAEMC,O;;;;;;;;;;;;;6BACK;AAAA,wBAOH,KAAKpB,KAPF;AAAA,UAELqB,MAFK,eAELA,MAFK;AAAA,UAGLN,iBAHK,eAGLA,iBAHK;AAAA,UAILO,iBAJK,eAILA,iBAJK;AAAA,UAKLC,OALK,eAKLA,OALK;AAAA,UAMFC,SANE;;AAQP,UAAMC,KAAK,qBAAQD,SAAS,CAACC,KAAlB;AAAyBC,QAAAA,MAAM,EAAE;AAAjC,QAAX;;AAEA,UAAIC,SAAS,GAAGH,SAAS,CAACG,SAA1B;;AACA,UAAIN,MAAJ,EAAY;AACV,YAAIG,SAAS,CAACI,KAAV,GAAkBT,YAAtB,EAAoC;AAClCQ,UAAAA,SAAS,IAAI,qBAAb;AACD;;AACD,YAAIH,SAAS,CAACI,KAAV,GAAkBT,YAAtB,EAAoC;AAClCQ,UAAAA,SAAS,IAAI,mBAAb;AACD;AACF;;AAED,aAAOZ,iBAAiB,CACtBO,iBAAiB,CACf,4CACME,SADN;AAEE,QAAA,SAAS,EAAEG,SAFb;AAGE,QAAA,KAAK,EAAEF,KAHT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SADe,CADK,CAAxB;AASD;;;;EA9BmB7C,KAAK,CAACC,S;;AAiC5B,IAAMgD,SAAS,GAAG;AAChB9B,EAAAA,SADgB,qBACNC,KADM,EACC;AACfmB,IAAAA,YAAY,GAAGnB,KAAK,CAAC4B,KAArB;AACA,WAAO;AACLA,MAAAA,KAAK,EAAE5B,KAAK,CAAC4B;AADR,KAAP;AAGD;AANe,CAAlB;AASA,IAAME,SAAS,GAAG;AAChBC,EAAAA,IADgB,gBACX/B,KADW,EACJI,OADI,EACK;AACnB,QAAM4B,SAAS,GAAG5B,OAAO,CAACI,OAAR,GAAkBoB,KAApC;AACA,QAAMK,UAAU,GAAGjC,KAAK,CAAC4B,KAAzB,CAFmB,CAInB;;AACA,QAAII,SAAS,KAAKC,UAAlB,EAA8B;AAC5B;AACD,KAPkB,CASnB;;;AACAjC,IAAAA,KAAK,CAACuB,OAAN,CAAcS,SAAd,EAAyBC,UAAzB,EAVmB,CAYnB;AACA;AACA;AACA;;AACA7B,IAAAA,OAAO,CAACI,OAAR,GAAkBoB,KAAlB,GAA0BK,UAA1B;AACD;AAlBe,CAAlB;AAqBA,IAAMC,eAAe,GAAGhD,UAAU,CAChC,KADgC,EAEhC4C,SAFgC,EAGhC,UAAChB,OAAD,EAAUV,OAAV;AAAA,SAAuB;AACrBkB,IAAAA,iBAAiB,EAAER,OAAO,CAACqB,UAAR,EADE;AAErBd,IAAAA,MAAM,EAAEjB,OAAO,CAACiB,MAAR;AAFa,GAAvB;AAAA,CAHgC,CAAV,CAQtBpC,UAAU,CACR,KADQ,EAER4C,SAFQ,EAGR,UAACf,OAAD;AAAA,SAAc;AACZC,IAAAA,iBAAiB,EAAED,OAAO,CAACE,UAAR;AADP,GAAd;AAAA,CAHQ,CAAV,CAMEI,OANF,CARsB,CAAxB;AAiBA,IAAMgB,OAAO,GAAG,CAAC;AACfC,EAAAA,KAAK,EAAE,MADQ;AAEfC,EAAAA,SAAS,EAAE,MAFI;AAGfC,EAAAA,GAAG,EAAE;AAHU,CAAD,EAIb;AACDF,EAAAA,KAAK,EAAE,KADN;AAEDC,EAAAA,SAAS,EAAE,KAFV;AAGDC,EAAAA,GAAG,EAAE;AAHJ,CAJa,EAQb;AACDF,EAAAA,KAAK,EAAE,SADN;AAEDC,EAAAA,SAAS,EAAE,SAFV;AAGDC,EAAAA,GAAG,EAAE;AAHJ,CARa,CAAhB;;IAcMC,gB;;;;;;;;;;;;;;;;;UACJC,K,GAAQ;AACNC,MAAAA,IAAI,EAAE,CAAC;AACLH,QAAAA,GAAG,EAAE,GADA;AAELI,QAAAA,IAAI,EAAE,YAFD;AAGLC,QAAAA,GAAG,EAAE,EAHA;AAILC,QAAAA,OAAO,EAAE;AAJJ,OAAD,EAKH;AACDN,QAAAA,GAAG,EAAE,GADJ;AAEDI,QAAAA,IAAI,EAAE,WAFL;AAGDC,QAAAA,GAAG,EAAE,EAHJ;AAIDC,QAAAA,OAAO,EAAE;AAJR,OALG,EAUH;AACDN,QAAAA,GAAG,EAAE,GADJ;AAEDI,QAAAA,IAAI,EAAE,WAFL;AAGDC,QAAAA,GAAG,EAAE,EAHJ;AAIDC,QAAAA,OAAO,EAAE;AAJR,OAVG;AADA,K;UAmBRC,U,GAAa;AACXC,MAAAA,IAAI,EAAE;AACJC,QAAAA,GAAG,EAAEd;AADD;AADK,K;;UAMbX,O,GAAU,UAACS,SAAD,EAAYC,UAAZ,EAA2B;AAAA,UAC3BS,IAD2B,GAClB,MAAKD,KADa,CAC3BC,IAD2B;AAEnC,UAAMO,OAAO,GAAGP,IAAI,CAACV,SAAD,CAApB;;AAEA,YAAKkB,QAAL,CACExD,MAAM,CAAC,MAAK+C,KAAN,EAAa;AACjBC,QAAAA,IAAI,EAAE;AACJS,UAAAA,OAAO,EAAE,CAAC,CAACnB,SAAD,EAAY,CAAZ,CAAD,EAAiB,CAACC,UAAD,EAAa,CAAb,EAAgBgB,OAAhB,CAAjB;AADL;AADW,OAAb,CADR;AAOD,K;;;;;;;6BAEQ;AAAA;;AACP,aAEE,oBAAC,KAAD;AACE,QAAA,OAAO,EAAEb,OADX;AAEE,QAAA,UAAU,EAAE,KAAKK,KAAL,CAAWC,IAFzB;AAGE,QAAA,UAAU,EAAE,KAAKI,UAHnB;AAIE,QAAA,KAAK,EAAE,eAACM,MAAD,EAASxB,KAAT;AAAA,iBAAoB;AACzBA,YAAAA,KAAK,EAALA,KADyB;AAEzBL,YAAAA,OAAO,EAAE,MAAI,CAACA;AAFW,WAApB;AAAA,SAJT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAFF;AAaD;;;;EArD4B3C,KAAK,CAACC,S;;AAyDrC,IAAMwE,IAAI,GAAGrE,eAAe,CAACS,YAAD,CAAf,CAA8B+C,gBAA9B,CAAb;AAEA,eAAea,IAAf","sourcesContent":["import React, { Component } from 'react'\nimport { Table, Card } from 'antd';\nimport { DragDropContext,DragSource,DropTarget,ConnectDropTarget,ConnectDragSource,DropTargetMonitor,DropTargetConnector,DragSourceConnector,DragSourceMonitor,\n} from 'react-dnd'\nimport HTML5Backend from 'react-dnd-html5-backend';\nimport update from 'immutability-helper';\n\nimport './dashboard.css';\n\nimport { XYCoord } from 'dnd-core'\n\nconst Types = {\n  CARD1: 'card1'\n};\n\nconst cardSource = {\n  beginDrag(props) {\n    // Return the data describing the dragged item\n    const item = { id: props.id };\n    return item;\n  },\n\n  endDrag(props, monitor, component, CardActions) {\n    if (!monitor.didDrop()) {\n      return;\n    }\n\n    // When dropped on a compatible target, do something\n    const item = monitor.getItem();\n    const dropResult = monitor.getDropResult();\n    CardActions.moveCardToList(item.id, dropResult.listId);\n  }\n};\n\n/**\n * Specifies which props to inject into your component.\n */\nfunction collect(connect, monitor) {\n  return {\n    // Call this function inside render()\n    // to let React DnD handle the drag events:\n    connectDragSource: connect.dragSource(),\n    // You can ask the monitor about the current drag state:\n    isDragging: monitor.isDragging()\n  };\n}\n\nfunction Card1(props) {\n  // Your component receives its own props as usual\n  const { id } = props;\n\n  // These two props are injected by React DnD,\n  // as defined by your `collect` function above:\n  const { isDragging, connectDragSource } = props;\n\n  return connectDragSource(\n    <div>\n      I am a draggable card number {id}\n      {isDragging && ' (and I am being dragged now)'}\n    </div>\n  );\n}\n\n\n\n\nlet dragingIndex = -1;\n\nclass BodyRow extends React.Component {\n  render() {\n    const {\n      isOver,\n      connectDragSource,\n      connectDropTarget,\n      moveRow,\n      ...restProps\n    } = this.props;\n    const style = { ...restProps.style, cursor: 'move' };\n\n    let className = restProps.className;\n    if (isOver) {\n      if (restProps.index > dragingIndex) {\n        className += ' drop-over-downward';\n      }\n      if (restProps.index < dragingIndex) {\n        className += ' drop-over-upward';\n      }\n    }\n\n    return connectDragSource(\n      connectDropTarget(\n        <tr\n          {...restProps}\n          className={className}\n          style={style}\n        />\n      )\n    );\n  }\n}\n\nconst rowSource = {\n  beginDrag(props) {\n    dragingIndex = props.index;\n    return {\n      index: props.index,\n    };\n  },\n};\n\nconst rowTarget = {\n  drop(props, monitor) {\n    const dragIndex = monitor.getItem().index;\n    const hoverIndex = props.index;\n\n    // Don't replace items with themselves\n    if (dragIndex === hoverIndex) {\n      return;\n    }\n\n    // Time to actually perform the action\n    props.moveRow(dragIndex, hoverIndex);\n\n    // Note: we're mutating the monitor item here!\n    // Generally it's better to avoid mutations,\n    // but it's good here for the sake of performance\n    // to avoid expensive index searches.\n    monitor.getItem().index = hoverIndex;\n  },\n};\n\nconst DragableBodyRow = DropTarget(\n  'row',\n  rowTarget,\n  (connect, monitor) => ({\n    connectDropTarget: connect.dropTarget(),\n    isOver: monitor.isOver(),\n  }),\n)(\n  DragSource(\n    'row',\n    rowSource,\n    (connect) => ({\n      connectDragSource: connect.dragSource(),\n    }),\n  )(BodyRow),\n);\n\nconst columns = [{\n  title: 'Name',\n  dataIndex: 'name',\n  key: 'name',\n}, {\n  title: 'Age',\n  dataIndex: 'age',\n  key: 'age',\n}, {\n  title: 'Address',\n  dataIndex: 'address',\n  key: 'address',\n}];\n\nclass DragSortingTable extends React.Component {\n  state = {\n    data: [{\n      key: '1',\n      name: 'John Brown',\n      age: 32,\n      address: 'New York No. 1 Lake Park',\n    }, {\n      key: '2',\n      name: 'Jim Green',\n      age: 42,\n      address: 'London No. 1 Lake Park',\n    }, {\n      key: '3',\n      name: 'Joe Black',\n      age: 32,\n      address: 'Sidney No. 1 Lake Park',\n    }],\n  }\n\n  components = {\n    body: {\n      row: DragableBodyRow,\n    },\n  }\n\n  moveRow = (dragIndex, hoverIndex) => {\n    const { data } = this.state;\n    const dragRow = data[dragIndex];\n\n    this.setState(\n      update(this.state, {\n        data: {\n          $splice: [[dragIndex, 1], [hoverIndex, 0, dragRow]],\n        },\n      }),\n    );\n  }\n\n  render() {\n    return (\n\n      <Table\n        columns={columns}\n        dataSource={this.state.data}\n        components={this.components}\n        onRow={(record, index) => ({\n          index,\n          moveRow: this.moveRow,\n        })}\n      />\n\n    );\n  }\n}\n\n\nconst Demo = DragDropContext(HTML5Backend)(DragSortingTable);\n\nexport default Demo;\n"]},"metadata":{},"sourceType":"module"}